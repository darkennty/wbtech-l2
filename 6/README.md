# L2.6

## Задача

Что выведет программа?

Объяснить поведение срезов при передаче их в функцию.

```
package main

import (
  "fmt"
)

func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}

func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
```

## Решение

Слайс - обычный массив, в структуре которого появляется capacity (вместимость). Если базовый массив имеет лишь указатель на первый его элемент и длину самого массива, то слайс обладает свойством динамического массива за счет аллокации (выделения/распределения) новой памяти при превышении длины его вместимости. В обычных случаях реаллокация памяти происходит по формуле capacity = capacity * 2, однако если длина превысила 256 - аллокация проходит по формуле newcap += (newcap + 3 \* threshold) >> 2 (т.е. увеличение в 1.25x раза).

Когда происходит передача срезов в функцию, в неё передаётся указатель на массив элементов unsafe.Pointer, тем самым при изменении среза внутри функции его данные будут изменены и в остальной части программы.

Как только, при добавлении нового элемента с помощью операции append(), длина (length) массива превышает его вместимость (capacity), создаётся новый массив с большей вместимостью, вычисление размера которой было описано выше. Если это произошло внутри функции, то при возвращении в основную часть программы изменения видны не будут, т.к. внутри функции у среза поменяется его адрес в памяти, соответственно работа в функции будет вестись с совершенно другим массивом.

В данной программе в функцию modifySlice() передаётся слайс s (точнее указатель на него). В функции сначала изменяется первый его элемент, и, так как функция работает с данными по ссылке, изменения происходят и в основной части программы. Но после того, как в функции modifySlice() к переданному слайсу добавляется новый элемент, а длина слайса становится больше вместимости, образуется новый слайс с теми же данными, но с большей вместимостью и новой ссылкой на этот слайс. После данной операции функция работает с другим по адресу в памяти слайсом, следовательно те изменения, которые происходят со слайсом в функции, никак не затрагивают слайс, созданный в основной части программы.

## Пример запуска программы

```
$ go run 6/main.go
[3 2 3]
```